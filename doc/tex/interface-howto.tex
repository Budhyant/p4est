
\documentclass[letterpaper,11pt]{article}

\usepackage{amsmath}
\usepackage{cite}
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{url}
\usepackage{xspace}

\usetikzlibrary{fit}
\usetikzlibrary{positioning}
\usetikzlibrary{trees}
\input{tikzstyles}

\newcommand{\dealii}{\texttt{deal.II}\xspace}
\newcommand{\pforest}{\texttt{p4est}\xspace}

\newcommand{\figref}[1]{Figure~\ref{fig:#1}}

\author{Carsten Burstedde}
\title{Brief \pforest interface schematics}

\begin{document}

\maketitle

\begin{abstract}
We describe the general procedure of using \pforest from application codes.
\pforest is a software library that stores and modifies a forest-of-octrees
refinement structure using distributed (MPI) parallelism.  It expects the
description of the domain as a coarse mesh of conforming hexahedra.
Non-conforming adaptive mesh refinement (AMR), coarsening, and other operations
that modify the forest are implemented as \pforest API functions.  To inform
the application about the refinement structure, several methods are provided
that encode this information.
\end{abstract}

\section{Starting point}

We generally separate the adaptive mesh refinement (AMR) topology from any
numerical information.  The former is stored and modified internally by the
\pforest software library, while an application is free to define the way it
uses this information and arranges numerical and other data.  This document is
inteded to describe the interface by which \pforest transfers mesh information
to the application.

The general, modular AMR pipeline is described in
\cite{BursteddeGhattasStadlerEtAl08}, which is not specific to \pforest but can
in principle be applied to any AMR provider.  The \pforest algorithms and main
interface routines are destribed in \cite{BursteddeWilcoxGhattas11}.
% \cite{IsaacBursteddeGhattas12}
An example usage of \pforest as scalable mesh backend for the general-purpose
finite element software \dealii is described in
\cite{BangerthBursteddeHeisterEtAl11}.  A reference implementation of \pforest
in \texttt{C} can be freely downloaded \cite{Burstedde10} and used and extended
under the GNU General Public License.  This software is best installed
standalone into a dedicated directory, where an application code can then find
the header and library files to compile and link against, respectively.

In this document, we document the three distinct tasks to
\begin{description}
\item[A] create a coarse mesh (\figref{partA}),
\item[B] modify the refinement and partition structure internal to \pforest
  (\figref{partB}),
\item[C] and to transfer the mesh information to an application.
\end{description}
Unless indicated otherwise, all operations described below are understood as
MPI collectives, that is, they are called on all processors simultaneously.
Currently, part A needs to be performed redundantly on all processors, which is
acceptable for up to $10^5$--$10^6$ coarse cells (octree roots).  In parts B
and C, runtime and memory are roughly proportional to the number of elements
(octree leaves) on a given processor, independent of the number of octrees.

\begin{figure}
\begin{center}
\begin{tikzpicture}[node distance=3ex,
  grow via three points = {one child at (0.5,-1.5) and
  two children at (0.5,-1.5) and (0.5,-3.0)},
  edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}]

\tikzstyle{every node}=[action, anchor=west]
\tikzstyle{every child}=[arrseq]

\node (createconn) {\texttt{c =} (choose one below)}
child  {
%\node (CAD) {CAD / mesh generator / \ldots}
%  child {
  node (connnew) { \texttt{c = p4est\_connectivity\_new (\ldots)} }
  child {
    node (connfill) { \parbox{5.2cm}{\texttt{c.tree\_to\_tree[\ldots]~= \ldots}\\
                                   %\texttt{c\ldots}\\
                                   etc.\ (populate members)}}
  }
}
%\draw [arrseq] (CAD) -- (connnew);
%\draw [arrseq] (connnew) -- (connfill);
%\node[group, fit=(CAD) (connnew) (connfill)] (cadpipe) {};
child [missing] {}
child {
  node (newunit) { \texttt{c = p4est\_connectivity\_new\_unitcube ()} }
}
child {
  node (newstar) { \texttt{c = p4est\_connectivity\_new\_\ldots ()} }
}
child {
  node (conndestroy) { \texttt{p4est\_connectivity\_destroy (c)} }
};

\node[robject, xshift=12.5cm] (theconn) { \texttt{c} };
\draw[arrdat] (createconn) -- (theconn);
%\draw[arrdat] (newunit.east) -- (theconn);
%\draw[arrdat] (newstar.east) -- (theconn);

\node[object] at (0, -1.5-.75) (cadinput) {CAD};
\node[object] at (0, -4.5-.75) (predef) {predef.};

%\node[object, right=of theconn] (topartb) { Part B };
%\draw[arrdat, dashed] (theconn.east) -- (topartb.west);

%\draw[arrdat] (theconn) -- (conndestroy.east);
\draw[arrdat] (cadinput) -- (connnew);
\draw[arrdat] (cadinput) -- (connfill);
\draw[arrdat] (predef) -- (newunit);
\draw[arrdat] (predef) -- (newstar);

\end{tikzpicture}
\end{center}
\caption{Part A, creating the coarse mesh connectivity.  The \pforest connectivity
  \texttt{c} is a \texttt{C struct} that contains numbers and orientations of
  neighboring coarse cells.  It can be created by translating CAD or mesh data
  file formats or by using one of several predefined \pforest
  functions.  The data format is documented in the extensive comment blocks in
  \texttt{p4est\_connectivity.h} (2D) and \texttt{p8est\_connectivity.h} (3D);
  see also \cite{BursteddeWilcoxGhattas11}.
  In the following, \texttt{p4est} always refers to both 2D and 3D.
}
\label{fig:partA}
\end{figure}

\begin{figure}
\begin{center}
\begin{tikzpicture}[%node distance=3ex,
  grow via three points = {one child at (0.5,-1.5) and
  two children at (0.5,-1.5) and (0.5,-3.0)},
  edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}]

\tikzstyle{every node}=[action, anchor=west]
\tikzstyle{every child}=[arrseq]

\node (p4estnew) {\parbox{4.5cm}{\texttt{p = p4est\_new (c)}\\
                                (modify \texttt{p} in-place below)}}
  child {
    node (p4estrefine) {\texttt{p4est\_refine (p)}}
  }
  child {
    node (p4estcoarsen) {\texttt{p4est\_coarsen (p)}}
  }
  child { 
    node (p4estbalance) {\texttt{p4est\_balance (p)}}
  }
  child {
    node (p4estpartition) {\texttt{p4est\_partition (p)}}
  }
  child {
    node (ghostnew) {\texttt{g = p4est\_ghost\_new (p)}}
    child {
      node (ghostdestroy) {\texttt{p4est\_ghost\_destroy (g)}}
    }
  }
  child [missing] {}
  child {
    node (p4estdestroy) {\texttt{p4est\_destroy (p)}}
  };

\node[object, xshift=-1.5cm] (cinput) {\texttt{c}};
\draw[arrdat] (cinput) -- (p4estnew);

\node[robject, xshift=11.2cm] (poutput) {\texttt{p}};
\draw[arrdat] (p4estnew) -- (poutput);
\node[robject, xshift=11.2cm, yshift=-7.5cm] (goutput) {\texttt{g}};
\draw[arrdat] (ghostnew) -- (goutput);

\node[robject, xshift=11.2cm, yshift=-1.5cm-.75cm] (flags) {flags};
\draw[arrdat] (flags) -- (p4estrefine);
\draw[arrdat] (flags) -- (p4estcoarsen);

\end{tikzpicture}
\end{center}
\caption{Part B, changing the refinement structure and partition.  With the
  connectivity \texttt{c} created in part A, we can create the distributed
  \pforest structure.  Several functions for its modification exist.  For a
  given \pforest snapshot, we can create a ghost layer of off-processor
  leaves, which will be outdated once \texttt{p} is changed again.  Refinement
  and coarsening are controlled by callback functions that usually query flags
  determined by the application.  The \texttt{C struct}s \texttt{p} and \texttt{g}
  can be examined directly by an application, for example to create and loop
  through its local and ghost leaf storage.
}
\label{fig:partB}
\end{figure}

\bibliographystyle{siam}
\bibliography{ccgo}

\end{document}
